<!DOCTYPE html>
<html>
<head>
    <title>Random Walk</title>
    <style>
        #canvas {
            width: 1000px;
            height: 1000px;
            border: 3px solid rgb(32, 136, 0);  /* These are the dimentions of the canvas */
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1000" height="1000"></canvas>  <!-- These are the dimentions of the canvas -->
    <script src="https://cdn.jsdelivr.net/npm/d3-quadtree@3"></script>
    <script>
        // Get the canvas element
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let area = 1;
        // Create an array of points
        const points = Array(100).fill().map(() => ({
            x: canvas.width/2,//+ (Math.random() - 0.5)*area,
            y: canvas.height/2, //+ (Math.random() - 0.5)*area,
            }));

        // Create a quadtree with the points
        let quadtree = d3.quadtree()
            .extent([[0, 0], [canvas.width, canvas.height]])
            .x(d => d.x)
            .y(d => d.y)
            .addAll(points);
        const threshold = 30; 




        // Function to draw a point
        function drawPoint(point, color) {
            let radius = 3;
            if (color ==="red") radius = 5;

            if (color === "green") radius = 8;
          

            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI); // x, y, radius, startAngle, endAngle
            ctx.fillStyle = color;
            ctx.fill();
     
            ctx.closePath();
        }

                // Function to draw a rectangle for a quadtree node
        // Function to draw a rectangle for a quadtree node
        function drawQuadtree(node, x1, y1, x2, y2) {
            ctx.beginPath(); // Start path before recursive calls
            (function drawNode(node, x1, y1, x2, y2) {
                if (node.length) {
                    const xm = (x1 + x2) / 2;
                    const ym = (y1 + y2) / 2;
                    if (node[0]) drawNode(node[0], x1, y1, xm, ym);
                    if (node[1]) drawNode(node[1], xm, y1, x2, ym);
                    if (node[2]) drawNode(node[2], x1, ym, xm, y2);
                    if (node[3]) drawNode(node[3], xm, ym, x2, y2);
                } else {
                    ctx.rect(x1, y1, x2 - x1, y2 - y1);
                }
            })(node, x1, y1, x2, y2);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 0.3;
            ctx.stroke(); // Stroke once after all rectangles are drawn
        }


        // Function to update the position of a point
        function updatePosition(point, color, neighbors) {
            let redGreenCount = 0, blackCount = 0, xSum = 0, ySum = 0, xBlackSum = 0, yBlackSum = 0;


            // Combine counting and center of mass calculation for red/green and separate counting for black
            neighbors.forEach(neighbor => {
                if (neighbor.color === 'red' || neighbor.color === 'green') {
                    redGreenCount++;
                    xSum += neighbor.x;
                    ySum += neighbor.y;
                }
                if (neighbor.color === 'black') {
                    blackCount++;
                    xBlackSum += neighbor.x;
                    yBlackSum += neighbor.y;
                }
            });

            // Calculate center of mass for red/green
            const xCenter = redGreenCount > 0 ? xSum / redGreenCount : 0;
            const yCenter = redGreenCount > 0 ? ySum / redGreenCount : 0;

            // Calculate center of mass for black
            const xBlackCenter = blackCount > 0 ? xBlackSum / blackCount : 0;
            const yBlackCenter = blackCount > 0 ? yBlackSum / blackCount : 0;

            // Calculate normalized vector pointing away from the center of mass
            const distance = Math.sqrt((point.x - xCenter) ** 2 + (point.y - yCenter) ** 2);
            const xNorm = distance > 0 ? (point.x - xCenter) / distance : 0;
            const yNorm = distance > 0 ? (point.y - yCenter) / distance : 0;

            // Calculate normalized vector for black center of mass
            const distanceBlack = Math.sqrt((point.x - xBlackCenter) ** 2 + (point.y - yBlackCenter) ** 2);
            const xBlackNorm = distanceBlack > 0 ? (point.x - xBlackCenter) / distanceBlack : 0;
            const yBlackNorm = distanceBlack > 0 ? (point.y - yBlackCenter) / distanceBlack : 0;

            // Movement logic based on color and neighbor presence
            if (color === 'black') {
                let dx, dy;
                if (redGreenCount > 0) {
                    // Move away from the center of mass of red and green points
                    dx = xNorm * 2;
                    dy = yNorm * 2;
                } else {
                    // Move randomly if no red or green neighbors
                    dx = (Math.random() - 0.5) * 10;
                    dy = (Math.random() - 0.5) * 10;
                }
                point.x = (point.x + dx + canvas.width) % canvas.width;
                point.y = (point.y + dy + canvas.height) % canvas.height;
            } else if (color === "green") {
                let dx, dy;
                if (blackCount > 0) {
                    // Move away from the center of mass of black points
                    dx = xBlackNorm * 2;
                    dy = yBlackNorm * 2;
                }
                point.x = (point.x + dx + canvas.width) % canvas.width;
                point.y = (point.y + dy + canvas.height) % canvas.height;
            }



            
        }




        // Function to check if a point is close to any other point
        function isCloseToOtherPoint(point) {

       
            

            // Query the quadtree for points within the threshold distance
            let nearbyPoints = [];
            quadtree.visit((node, x1, y1, x2, y2) => { // Visit all nodes in the quadtree. The arguments are the node and the bounds of the node
                if (!node.length) { // If this is a leaf node
                    do {
                        var d = node.data; // Get the point. The point is stored in the data property of the node as
                        if (d === point) continue; // Skip the point itself
                        const dx = point.x - d.x;
                        const dy = point.y - d.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < threshold) {
                            nearbyPoints.push(d); // Add the point to the nearby points array
                            //return true; // Stop visiting when we find a nearby point
                        }
                    } while (node = node.next);
                } // If this is not a leaf node, continue visiting the tree
                // Don't visit subtrees if their closest point wouldn't be within the threshold distance
                return x1 > point.x + threshold || x2 + threshold < point.x || y1 > point.y + threshold || y2 + threshold < point.y;  // Return true if the point is outside the threshold distance. This will stop visiting the subtree
            });

            // if there is no nearby point, return false. If there is a nearby point, return the color of the nearby point
            return nearbyPoints 
            
        }



        function checkForAddition(point, color, greenNeighbors) {
/*             if (color === 'red' && Math.random() < 0.001) {
                
                // Add a new point
                let newPoint = {
                    x: point.x ,
                    y: point.y ,
                    color: 'black'
                };
                points.push(newPoint);
             
            } */
    

        }
        
 

        // Function to animate the points
        function animate() {

            ctx.clearRect(0, 0, canvas.width, canvas.height);            
            //plotQuadtree()
            points.forEach(point => {
                let neighbors = isCloseToOtherPoint(point);
                let greenNeighbors = neighbors.filter(neighbor => neighbor.color === 'green');


             if (point.color != "green") {  
                if (neighbors.length < 8) {
                    point.color = 'red';
                } else {
                    point.color = 'black';
                }
             } 

             if (point.color === "red" && Math.random() < 0.0001) {

                point.color = "green";

                }

                checkForAddition(point, point.color, greenNeighbors);
                updatePosition(point, point.color, neighbors);
                drawPoint(point, point.color);
            });

            quadtree = d3.quadtree()
                .x(d => d.x)
                .y(d => d.y)
                .addAll(points);




            requestAnimationFrame(animate);
        }


        function plotQuadtree(){
            const quadtree = d3.quadtree()
                .extent([[0, 0], [canvas.width, canvas.height]]) // Set the extent of the quadtree to the size of the canvas
                .x(d => d.x)
                .y(d => d.y)
                .addAll(points);

            // Draw the quadtree
            quadtree.visit((node, x1, y1, x2, y2) => { 
                drawQuadtree(node, x1, y1, x2, y2); 
                return false; // Continue visiting all nodes. 
            }); 
        }

        // Start the animation
        animate();
    </script>
</body>
</html>